// https://www.acmicpc.net/problem/17471 게리맨더링 (조합 + BFS)

#include<stdio.h>
#include<vector>
#include<queue>

using namespace std;

int N;
int arPeopleCnt[11] = { 0, };
vector<int> v_node[11];
vector<int> v_region;
int arUnion[11] = { 0, };
bool bVisit[11] = { 0, };
bool bCheck[11] = { 0, };
int g_people_sum = 0;
int Total = 0;
int diff_min = 100000;

// 새로운 지역인지 확인하고, 새 지역인 경우 갯수를 구함
int IsNewField(int index)
{
	int PeopleCount = 0;

	if (bCheck[index] == true)
		return 0;

	bCheck[index] = true;
	PeopleCount = arPeopleCnt[index];

	for (int i = 0; i < v_node[index].size(); i++)
	{
		PeopleCount += IsNewField(v_node[index].at(i));
	}

	return PeopleCount;
}

// 조합이 한 덩어리인지 확인
bool IsOneRegion(int start, int total_cnt)
{
	int cnt = 0;

	queue<int> q;
	q.push(start);
	
	while (!q.empty())
	{
		int c_index = q.front();
		q.pop();
		bVisit[c_index] = true;

		g_people_sum += arPeopleCnt[c_index];
		cnt++;

		if (cnt == total_cnt)
			return true;

		for (int i = 0; i < v_node[c_index].size(); i++)
		{
			int n_index = v_node[c_index].at(i);
	
			if (arUnion[n_index] != true)
				continue;

			if (bVisit[n_index] == true)
				continue;

			q.push(n_index);
		}
	}

	return false;
}

void clear()
{
	for (int i = 0; i < N; i++)
	{
		bVisit[i] = 0;
		arUnion[i] = 0;
	}
	g_people_sum = 0;
	v_region.clear();
	
	return;
}

int main()
{
	int arPeoplePerField[11] = { 0, };
	int idx = 0;

	scanf("%d", &N);

	for (int i = 1; i <= N; i++)
	{
		scanf("%d", &arPeopleCnt[i]);
		Total += arPeopleCnt[i];
	}

	for (int i = 1; i <= N; i++)
	{
		int cnt;
		scanf("%d", &cnt);

		for (int j = 0; j < cnt; j++)
		{
			int node;
			scanf("%d", &node);

			v_node[i].push_back(node);
		}
	}

	for (int i = 1; i <= N; i++)
	{
		int ret = IsNewField(i);
		if (ret != 0)
		{
			arPeoplePerField[idx] = ret;
			idx++;
		}
	}

	if (idx == 1)
	{
		// 직접 구역을 나눠 계산 필요
		for (int i = 1; i < (1 << N); i++)
		{
			for (int j = 0; j < N; j++)
			{
				if (i & (1 << j))
				{
					arUnion[j + 1] = 1;
					v_region.push_back(j + 1);
				}
			}

			if (arUnion[1] && arUnion[3] && arUnion[4] && arUnion[8])
				printf("");

			if (true == IsOneRegion(v_region.at(0), v_region.size()))
			{
				int Region1 = g_people_sum;
				int Region2 = Total - g_people_sum;

				int diff = Region1 - Region2;

				if (diff < 0)
					diff = 0 - diff;

				if (diff < diff_min)
				{
					diff_min = diff;
				}
			}

			clear();
		}

		if (diff_min == 100000)
			printf("-1");
		else
			printf("%d", diff_min);

	}
	else if (idx == 2)
	{
		// 단 두개이기 때문에 바로 계산 가능
		printf("%d", arPeoplePerField[1] - arPeoplePerField[0] > 0 ? arPeoplePerField[1] - arPeoplePerField[0] : arPeoplePerField[0] - arPeoplePerField[1]);
	}
	else if (idx > 2)
	{
		// 이미 지역이 두개 초과로, 두개로 나눌 수 없음
		printf("-1");
	}

	return 0;
}
